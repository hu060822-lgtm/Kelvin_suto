<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>喀爾文：全方位素頭防線 v3.0</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; touch-action: manipulation; }
        #game-stage { position: relative; width: 100vw; height: 100vh; background: radial-gradient(circle, #222 0%, #000 80%); overflow: hidden; }
        
        /* 中央安全區 */
        #safe-zone {
            position: absolute;
            top: 50%; left: 50%;
            width: 70px; height: 70px;
            margin: -35px 0 0 -35px;
            background: #f1c40f;
            border-radius: 50%;
            box-shadow: 0 0 30px #f1c40f;
            display: flex; align-items: center; justify-content: center;
            font-weight: bold; color: black; font-size: 14px; z-index: 10;
        }

        .calvin-enemy {
            position: absolute;
            width: 65px; height: 65px;
            border-radius: 50%;
            border: 2px solid #fff;
            background-size: cover;
            background-position: center;
            z-index: 5;
            pointer-events: auto; /* 確保可以點擊 */
        }

        /* UI 層 */
        .overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 100; color: white; text-align: center; padding: 20px; box-sizing: border-box; }
        #info-ui { position: absolute; top: 20px; width: 100%; text-align: center; color: white; z-index: 20; }
        #score-text { font-size: 24px; font-weight: bold; }
        #timer-text { font-size: 16px; color: #aaa; }
        
        .btn { padding: 15px 50px; background: #e74c3c; color: white; border: none; border-radius: 50px; font-size: 20px; font-weight: bold; margin-top: 20px; box-shadow: 0 5px 15px rgba(231,76,60,0.4); }
        .mode-hint { color: #ff4757; font-weight: bold; margin-top: 10px; display: none; animation: flash 1s infinite; }
        @keyframes flash { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
    </style>
</head>
<body>

    <div id="game-stage">
        <div id="info-ui">
            <div id="score-text">防禦次數: 0</div>
            <div id="timer-text">生存時間: 0s</div>
            <div id="mode-hint" class="mode-hint">⚠️ 偵測到不規則移動！</div>
        </div>
        <div id="safe-zone">核心</div>
    </div>

    <div id="start-ui" class="overlay">
        <h1 style="color:#f1c40f">核心保衛戰</h1>
        <div style="text-align: left; background: #222; padding: 20px; border-radius: 15px; line-height: 1.6;">
            <p>1. 喀爾文會從四周試圖進入核心。</p>
            <p>2. <b>點擊喀爾文</b> 將他們擊退。</p>
            <p>3. 隨時間推移，他們會<b>跑得更快</b>。</p>
            <p>4. 40秒後，將進入<b>不規則移動模式</b>！</p>
        </div>
        <button class="btn" onclick="realStartGame()">我知道了，開始！</button>
    </div>

    <div id="end-ui" class="overlay" style="display:none">
        <h1 style="color:#ff4757; font-size: 40px;">你被素頭了！</h1>
        <p id="final-stat" style="font-size: 20px;"></p>
        <button class="btn" onclick="location.reload()">重新啟動防線</button>
    </div>

    <script>
        const stage = document.getElementById('game-stage');
        let score = 0;
        let isGameOver = false;
        let startTime = 0;
        let baseSpeed = 1.2;
        let spawnRate = 1200;

        // 修改後的開始函數，確保 UI 關閉
        function realStartGame() {
            document.getElementById('start-ui').style.display = 'none';
            startTime = Date.now();
            isGameOver = false;
            updateTimer();
            spawnLoop();
        }

        function updateTimer() {
            if (isGameOver) return;
            const elapsed = Math.floor((Date.now() - startTime) / 1000);
            document.getElementById('timer-text').innerText = `生存時間: ${elapsed}s`;
            
            // 每 5 秒提升基礎速度
            baseSpeed = 1.2 + (elapsed / 5) * 0.3;
            // 縮短生成間隔
            spawnRate = Math.max(400, 1200 - (elapsed * 10));

            if (elapsed >= 40) {
                document.getElementById('mode-hint').style.display = 'block';
            }
            setTimeout(updateTimer, 1000);
        }

        function createEnemy() {
            if (isGameOver) return;

            const enemy = document.createElement('div');
            enemy.className = 'calvin-enemy';
            enemy.style.backgroundImage = "url('12672.jpg')";
            
            // 隨機出生位置
            let x, y;
            const side = Math.floor(Math.random() * 4);
            if (side === 0) { x = Math.random() * window.innerWidth; y = -70; }
            else if (side === 1) { x = window.innerWidth + 70; y = Math.random() * window.innerHeight; }
            else if (side === 2) { x = Math.random() * window.innerWidth; y = window.innerHeight + 70; }
            else { x = -70; y = Math.random() * window.innerHeight; }

            enemy.dataset.x = x;
            enemy.dataset.y = y;
            enemy.dataset.seed = Math.random() * 100; // 隨機種子用於不規則移動
            
            // 點擊事件 (支援手機觸控)
            const handleHit = (e) => {
                e.preventDefault();
                e.stopPropagation();
                repel(enemy);
            };
            enemy.addEventListener('touchstart', handleHit, {passive: false});
            enemy.addEventListener('mousedown', handleHit);

            stage.appendChild(enemy);
            moveEnemy(enemy);
        }

        function moveEnemy(enemy) {
            let internalTime = 0;
            const moveInterval = setInterval(() => {
                if (isGameOver) { clearInterval(moveInterval); return; }
                if (!enemy.parentNode) { clearInterval(moveInterval); return; }

                const elapsed = (Date.now() - startTime) / 1000;
                const targetX = window.innerWidth / 2 - 32;
                const targetY = window.innerHeight / 2 - 32;
                
                let curX = parseFloat(enemy.dataset.x);
                let curY = parseFloat(enemy.dataset.y);
                
                const dx = targetX - curX;
                const dy = targetY - curY;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < 35) {
                    gameOver();
                    clearInterval(moveInterval);
                    return;
                }

                // 基礎向量
                let vx = (dx / dist) * baseSpeed;
                let vy = (dy / dist) * baseSpeed;

                // 40秒後的不規則移動邏輯
                if (elapsed > 40) {
                    const wave = Math.sin(internalTime * 0.1 + enemy.dataset.seed) * 3; // 左右晃動強度
                    // 計算垂直於前進方向的向量
                    const perpX = -(dy / dist) * wave;
                    const perpY = (dx / dist) * wave;
                    vx += perpX;
                    vy += perpY;
                }

                enemy.dataset.x = curX + vx;
                enemy.dataset.y = curY + vy;
                
                enemy.style.left = enemy.dataset.x + 'px';
                enemy.style.top = enemy.dataset.y + 'px';
                internalTime++;
            }, 20);
        }

        function repel(enemy) {
            if (isGameOver) return;
            score++;
            document.getElementById('score-text').innerText = `防禦次數: ${score}`;
            
            // 擊退動畫
            enemy.style.transform = "scale(1.8)";
            enemy.style.opacity = "0";
            enemy.style.transition = "all 0.2s";
            setTimeout(() => {
                if (enemy.parentNode) stage.removeChild(enemy);
            }, 200);
        }

        function spawnLoop() {
            if (isGameOver) return;
            createEnemy();
            setTimeout(spawnLoop, spawnRate);
        }

        function gameOver() {
            if (isGameOver) return;
            isGameOver = true;
            const elapsed = Math.floor((Date.now() - startTime) / 1000);
            document.getElementById('end-ui').style.display = 'flex';
            document.getElementById('final-stat').innerText = `防禦了 ${score} 次，堅持了 ${elapsed} 秒`;
            stage.style.filter = "invert(1) hue-rotate(180deg)";
        }
    </script>
</body>
</html>
